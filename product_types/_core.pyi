from __future__ import annotations

import weakref

from types import UnionType
from typing import Any, overload, Iterator, ClassVar
from typing_extensions import TypeForm

type _IorT[T] = Intersection[T] | T
type IntersectionOrT[T] = _IorT[T]
type _IorTy[T] = Intersection[T] | type[T]
type IntersectionOrType[T] = _IorTy[T]

class IntersectionMeta[ItemTs](type): 
    _cache: ClassVar[weakref.WeakValueDictionary]

    @overload
    def __new__[NewItemTs](mcs, name:str, v1: Intersection[NewItemTs], **kwargs) -> Intersection[NewItemTs]: ...

    @overload
    def __new__(
        mcs, 
        name: str, 
        bases: tuple[type, ...], 
        namespace: dict[str, Any],
        types: frozenset[type] | None = None
    ) -> Intersection[ItemTs]:
        ...

    # NOTE: Pyright evaluates the raw `OtherItemTs` in the Intersection class, so by the time we get to this metaclass
    # call, A | B | C has already evaluated to UnionType (which has no type parameters to inspect). Thus, to satisfy
    # the type checker, we override __class_getitem__ in Intersection to provide annotations.
    #
    # def __getitem__[OtherItemTs](cls, item: TypeForm[OtherItemTs] | OtherItemTs) -> IntersectionMeta[OtherItemTs]:
    #     """
    #     Type constructor: Intersection[A | B | C]
        
    #     Supports:
    #     - Intersection[float | int | str]
    #     - Intersection[float, int, str] (via tuple unpacking)
    #     - Intersection[Intersection[float] | int] (flattening)
    #     """
    #     ...
    
    def __eq__(cls, other: Any) -> bool: ...
    
    def __hash__(cls) -> int:...

    def __contains__[OtherItemTs](cls, item: type[OtherItemTs] | IntersectionMeta[OtherItemTs]) -> bool: ...

    def __iter__(cls) -> Iterator[type]:...

    def __len__(cls) -> int:... 
    
    def __repr__(cls) -> str: ...
    
    def __and__[I,T](cls : type[I], other: IntersectionOrType[T]) -> IntersectionMeta[I | T]: ...

    def __rand__[I,T](cls : type[I], other: IntersectionOrType[T]) -> IntersectionMeta[I | T]: ...
    
    def __instancecheck__(cls, instance: Any) -> bool: ...

    def __subclasscheck__(cls, subclass: Any) -> bool: ...


class Intersection[ItemTs](metaclass=IntersectionMeta):
    #
    # NOTE: We enumerate these constructors since it's not possible to homogenize/flatten out any contained Intersection[...] within the args.
    # Ideally, we would be able to write something akin to...
    #   def __new__[*Ts](cls, *vs : Unpack[tuple[*IntersectionOrType[Ts]]) -> Intersection[Union[*Ts]]
    #  
    @overload
    def __new__[T1](cls, v1: _IorT[T1]) -> Intersection[T1]: ...
    @overload
    def __new__[T1, T2](cls, v1: _IorT[T1],v2: _IorT[T2],) -> Intersection[T1 | T2]: ...
    @overload
    def __new__[T1, T2, T3](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],) -> Intersection[T1 | T2 | T3]: ...
    @overload
    def __new__[T1, T2, T3, T4](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],) -> Intersection[T1 | T2 | T3 | T4]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],) -> Intersection[T1 | T2 | T3 | T4 | T5]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6, T7](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],v7: _IorT[T7],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6 | T7]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6, T7, T8](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],v7: _IorT[T7],v8: _IorT[T8],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6, T7, T8, T9](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],v7: _IorT[T7],v8: _IorT[T8],v9: _IorT[T9],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],v7: _IorT[T7],v8: _IorT[T8],v9: _IorT[T9],v10: _IorT[T10],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],v7: _IorT[T7],v8: _IorT[T8],v9: _IorT[T9],v10: _IorT[T10],v11: _IorT[T11],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | T11]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],v7: _IorT[T7],v8: _IorT[T8],v9: _IorT[T9],v10: _IorT[T10],v11: _IorT[T11],v12: _IorT[T12],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | T11 | T12]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],v7: _IorT[T7],v8: _IorT[T8],v9: _IorT[T9],v10: _IorT[T10],v11: _IorT[T11],v12: _IorT[T12],v13: _IorT[T13],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | T11 | T12 | T13]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],v7: _IorT[T7],v8: _IorT[T8],v9: _IorT[T9],v10: _IorT[T10],v11: _IorT[T11],v12: _IorT[T12],v13: _IorT[T13],v14: _IorT[T14],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | T11 | T12 | T13 | T14]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],v7: _IorT[T7],v8: _IorT[T8],v9: _IorT[T9],v10: _IorT[T10],v11: _IorT[T11],v12: _IorT[T12],v13: _IorT[T13],v14: _IorT[T14],v15: _IorT[T15],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | T11 | T12 | T13 | T14 | T15]: ...
    @overload
    def __new__[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16](cls, v1: _IorT[T1],v2: _IorT[T2],v3: _IorT[T3],v4: _IorT[T4],v5: _IorT[T5],v6: _IorT[T6],v7: _IorT[T7],v8: _IorT[T8],v9: _IorT[T9],v10: _IorT[T10],v11: _IorT[T11],v12: _IorT[T12],v13: _IorT[T13],v14: _IorT[T14],v15: _IorT[T15],v16: _IorT[T16],) -> Intersection[T1 | T2 | T3 | T4 | T5 | T6 | T7 | T8 | T9 | T10 | T11 | T12 | T13 | T14 | T15 | T16]: ...
    #
    # Runtime types will still track accurately, but for static checking we quit after 16-wide constructor calls.
    # You can always do `Intersection(T1,...,T16) & Intersection(T17,...) & ...` if you *really* want all the types.
    #
    def __new__(cls, *vs : Any) -> Intersection[UnionType]: ... 
    #
    #
    #
    
    def __init__[IncomingItemTs](self, *values: IncomingItemTs, **kwargs: IncomingItemTs) -> None: ...
    
    def __setattr__(self, name: str, value: ItemTs) -> None:...
    
    def __delattr__(self, name: str) -> None:...


    @classmethod
    def __class_getitem__[OtherItemTs](cls, item: TypeForm[OtherItemTs] | OtherItemTs) -> IntersectionMeta[OtherItemTs]: ...
    
    #
    # NOTE: For the __class_getitem__, the `OtherItemTs` is not evaluated to a runtime UnionType object, and so the above type hints
    # successfully propagate. Unfortunately, for __getitem__, the type is already evaluated to UnionType before we can intercept it;
    # and while 'TypeForm' should resolve the issue, requiring the caller to annotate with TypeForm[A|B|...] is unacceptable.
    # 
    # Ideally, TypeForm (or perhaps TypeForm by the time of Python 3.15+) will be able to capture such annotations before they can
    # be evaluated to an opqque UnionType. If this is specified, it's probably in PEP 747.
    #
    def __getitem__[OtherItemTs](self, types: TypeForm[OtherItemTs] | OtherItemTs) -> Intersection[OtherItemTs]: ...
    
    def __contains__(self, item: type[ItemTs] | TypeForm[ItemTs]) -> bool: ...

    def __iter__(self) -> Iterator[type[ItemTs]]: ... 

    def keys(self) -> Iterator[type[ItemTs]]: ...
    
    def values(self) -> Iterator[Intersection[ItemTs]]:...

    def items(self) -> Iterator[tuple[type, Intersection[ItemTs]]]:...

    def to[ItemT](self, typ: type[ItemT]) -> ItemT: ...

    def __and__[OtherItemTs](self, other: IntersectionOrT[OtherItemTs]) -> Intersection[ItemTs | OtherItemTs]: ...
    
    def __rand__[OtherItemT](self, other: OtherItemT) -> Intersection[ItemTs | OtherItemT]: ...
    
    def __truediv__(self, types: type | TypeForm[Any]) -> Intersection[Any]: ...
    
    def __eq__(self, other: Any) -> bool: ...

    def __hash__(self) -> int: ...
    
    def __repr__(self) -> str:...
    
    def __len__(self) -> int:...

